#!/bin/bash
# Pre-push hook for C++ projects - Testing and Dynamic Analysis
# This hook runs comprehensive tests, static analysis, and performance checks

# Note: set -e is NOT used to allow non-critical checks to continue on failure

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}üîç Pre-push Hook: Testing and Dynamic Analysis${NC}"
echo "=================================================="

# Detect build system
BUILD_SYSTEM="cmake"
if [ -f "meson.build" ]; then
    BUILD_SYSTEM="meson"
elif [ -f "CMakeLists.txt" ]; then
    BUILD_SYSTEM="cmake"
else
    echo -e "${YELLOW}‚ö†Ô∏è  Could not detect build system, defaulting to CMake${NC}"
    BUILD_SYSTEM="cmake"
fi

echo -e "${GREEN}‚úì Detected build system: $BUILD_SYSTEM${NC}"

# Function to run command and check result
run_check() {
    local description="$1"
    local command="$2"
    local critical="${3:-true}"

    echo -e "\n${BLUE}üìã $description${NC}"
    echo "Running: $command"

    if eval "$command"; then
        echo -e "${GREEN}‚úÖ $description - PASSED${NC}"
        return 0
    else
        if [ "$critical" = "true" ]; then
            echo -e "${RED}‚ùå $description - FAILED${NC}"
            echo -e "${RED}Please fix the issues above before pushing.${NC}"
            return 1
        else
            echo -e "${YELLOW}‚ö†Ô∏è  $description - WARNING${NC}"
            return 0
        fi
    fi
}

# Check if build directory exists and is configured
if [ ! -d "build" ]; then
    echo -e "${YELLOW}üìÅ Build directory not found, creating...${NC}"
    mkdir -p build
fi

# 1. Configure build system
echo -e "\n${BLUE}üîß Configuring build system...${NC}"
if [ "$BUILD_SYSTEM" = "cmake" ]; then
    if [ ! -f "build/CMakeCache.txt" ]; then
        echo "Configuring CMake..."
        if command -v ninja &> /dev/null; then
            cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Debug
        else
            cmake -B build -DCMAKE_BUILD_TYPE=Debug
        fi
    fi
else
    if [ ! -f "build/build.ninja" ]; then
        echo "Configuring Meson..."
        meson setup build --buildtype=debug
    fi
fi

# 2. Build the project
echo -e "\n${BLUE}üèóÔ∏è  Building project...${NC}"

# Detect number of cores cross-platform
if command -v nproc &> /dev/null; then
    CORES=$(nproc)
elif command -v sysctl &> /dev/null; then
    CORES=$(sysctl -n hw.ncpu 2>/dev/null || echo "4")  # macOS
else
    CORES=4  # fallback
fi

if [ "$BUILD_SYSTEM" = "cmake" ]; then
    if run_check "Build Project" "cmake --build build --parallel $CORES" true; then
        BUILD_PASSED=true
    else
        BUILD_PASSED=false
    fi
else
    if run_check "Build Project" "meson compile -C build" true; then
        BUILD_PASSED=true
    else
        BUILD_PASSED=false
    fi
fi

# 3. Run test suite
echo -e "\n${BLUE}üß™ Running test suite...${NC}"
if [ "$BUILD_PASSED" = "true" ]; then
    if [ "$BUILD_SYSTEM" = "cmake" ]; then
        if run_check "Test Suite" "ctest --test-dir build --output-on-failure" true; then
            TESTS_PASSED=true
        else
            TESTS_PASSED=false
        fi
    else
        if run_check "Test Suite" "meson test -C build --verbose" true; then
            TESTS_PASSED=true
        else
            TESTS_PASSED=false
        fi
    fi
else
    echo -e "${RED}‚ùå Skipping tests due to build failure${NC}"
    TESTS_PASSED=false
fi

# 4. Comprehensive static analysis with clang-tidy
echo -e "\n${BLUE}üîç Running comprehensive static analysis...${NC}"
if command -v clang-tidy &> /dev/null; then
    # Check if src directory exists
    if [ ! -d "src" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  src/ directory not found, skipping clang-tidy analysis${NC}"
    else
        # Create compile commands if not available
        if [ ! -f "build/compile_commands.json" ]; then
            echo "Generating compile commands..."
            if [ "$BUILD_SYSTEM" = "cmake" ]; then
                cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
            fi
        fi

        # Run comprehensive clang-tidy analysis
        if [ -f "build/compile_commands.json" ]; then
            # Find all .cpp files and process them individually
            CPP_FILES=$(find src -name "*.cpp" -type f 2>/dev/null)
            if [ -n "$CPP_FILES" ]; then
                echo "Analyzing C++ source files with clang-tidy..."
                TIDY_FAILED=false
                while IFS= read -r cpp_file; do
                    echo "  Checking: $cpp_file"
                    if ! clang-tidy "$cpp_file" -p build --quiet 2>&1; then
                        TIDY_FAILED=true
                    fi
                done <<< "$CPP_FILES"

                if [ "$TIDY_FAILED" = "true" ]; then
                    echo -e "${YELLOW}‚ö†Ô∏è  Some clang-tidy warnings found (non-critical)${NC}"
                else
                    echo -e "${GREEN}‚úÖ Static Analysis (clang-tidy) - PASSED${NC}"
                fi
            else
                echo -e "${YELLOW}‚ö†Ô∏è  No .cpp files found in src/, skipping analysis${NC}"
            fi
        else
            echo -e "${YELLOW}‚ö†Ô∏è  compile_commands.json not found, skipping static analysis${NC}"
        fi
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  clang-tidy not found, skipping static analysis${NC}"
fi

# 5. Run cppcheck for additional static analysis
echo -e "\n${BLUE}üîç Additional static analysis (cppcheck)...${NC}"
if command -v cppcheck &> /dev/null; then
    if [ -d "src" ]; then
        run_check "Static Analysis (cppcheck)" "cppcheck src/ --enable=all --inconclusive --std=c++{{ cookiecutter.cpp_standard }} --suppress=missingIncludeSystem --xml --xml-version=2 2>cppcheck-report.xml" false
    else
        echo -e "${YELLOW}‚ö†Ô∏è  src/ directory not found, skipping cppcheck analysis${NC}"
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  cppcheck not found, skipping additional static analysis${NC}"
fi

# 6. Run sanitizers if available (Debug build)
echo -e "\n${BLUE}üõ°Ô∏è  Running sanitizers...${NC}"
if [ "$BUILD_PASSED" = "true" ] && [ "$TESTS_PASSED" = "true" ]; then
    # Look for test binaries with more specific search
    TEST_BINARY=$(find build -path "*/tests/*" -type f -executable 2>/dev/null | grep -E "(test|Test)" | head -1)
    if [ -z "$TEST_BINARY" ]; then
        TEST_BINARY=$(find build -type f -executable 2>/dev/null | grep -E "(_test|test_|Test)" | head -1)
    fi

    if [ -n "$TEST_BINARY" ]; then
        # Check if binary has ASan symbols
        if command -v nm &> /dev/null; then
            if nm "$TEST_BINARY" 2>/dev/null | grep -q "__asan"; then
                echo "AddressSanitizer detected in $TEST_BINARY"
                run_check "AddressSanitizer" "ASAN_OPTIONS=detect_leaks=1 $TEST_BINARY" false
            else
                echo -e "${YELLOW}‚ö†Ô∏è  AddressSanitizer not enabled in test binary${NC}"
                echo "   Add -fsanitize=address to CMAKE_CXX_FLAGS to enable ASan"
            fi
        else
            echo -e "${YELLOW}‚ö†Ô∏è  'nm' tool not found, cannot verify ASan symbols${NC}"
            echo "   Skipping sanitizer checks"
        fi
    else
        echo -e "${YELLOW}‚ö†Ô∏è  No test binary found for sanitizer testing${NC}"
    fi
else
    if [ "$BUILD_PASSED" != "true" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Skipping sanitizers due to build failure${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Skipping sanitizers due to test failure${NC}"
    fi
fi

# 7. Code coverage analysis (if gcov/lcov available)
echo -e "\n${BLUE}üìä Code coverage analysis...${NC}"
if command -v gcov &> /dev/null && command -v lcov &> /dev/null; then
    if [ "$BUILD_PASSED" = "true" ] && [ "$TESTS_PASSED" = "true" ]; then
        echo "Generating coverage report..."
        if [ "$BUILD_SYSTEM" = "cmake" ]; then
            # Check if coverage flags are already set
            if ! grep -q "\-\-coverage" build/CMakeCache.txt 2>/dev/null; then
                echo "Reconfiguring build with coverage flags..."
                # Create separate coverage build to avoid overwriting main build
                if [ -d "build-coverage" ]; then
                    rm -rf build-coverage
                fi
                cmake -B build-coverage -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS="--coverage -g -O0" -DCMAKE_C_FLAGS="--coverage -g -O0"
                cmake --build build-coverage

                # Run tests to generate coverage data
                ctest --test-dir build-coverage --output-on-failure

                # Generate coverage report
                run_check "Coverage Analysis" "lcov --capture --directory build-coverage --output-file coverage.info && lcov --remove coverage.info '/usr/*' --output-file coverage.info && lcov --list coverage.info" false
            else
                echo "Coverage flags already enabled, using existing build..."
                # Run tests to generate coverage data
                ctest --test-dir build --output-on-failure

                # Generate coverage report
                run_check "Coverage Analysis" "lcov --capture --directory build --output-file coverage.info && lcov --remove coverage.info '/usr/*' --output-file coverage.info && lcov --list coverage.info" false
            fi
        fi
    fi
else
    echo -e "${YELLOW}üì¶ gcov/lcov not found, skipping coverage analysis${NC}"
fi

# 8. Performance benchmarks (if available)
echo -e "\n${BLUE}‚ö° Performance benchmarks...${NC}"
if [ -f "tests/benchmarks/" ] || [ -f "benchmark.cpp" ]; then
    if [ "$BUILD_PASSED" = "true" ]; then
        # Look for benchmark executables
        BENCHMARK_BINARY=$(find build -name "*benchmark*" -type f -executable 2>/dev/null | head -1)
        if [ -n "$BENCHMARK_BINARY" ]; then
            run_check "Performance Benchmarks" "$BENCHMARK_BINARY" false
        fi
    fi
else
    echo -e "${YELLOW}üìù No benchmarks found, skipping performance tests${NC}"
fi

# 9. Memory leak detection with Valgrind (if available)
echo -e "\n${BLUE}üß† Memory leak detection...${NC}"
if command -v valgrind &> /dev/null && [ "$TESTS_PASSED" = "true" ]; then
    # Find test binary with improved search
    TEST_BINARY=$(find build -path "*/tests/*" -type f -executable 2>/dev/null | grep -E "(test|Test)" | head -1)
    if [ -z "$TEST_BINARY" ]; then
        TEST_BINARY=$(find build -type f -executable 2>/dev/null | grep -E "(_test|test_|Test)" | head -1)
    fi

    if [ -n "$TEST_BINARY" ]; then
        echo "Running Valgrind memory check on $TEST_BINARY..."
        run_check "Memory Leak Detection" "valgrind --leak-check=full --show-leak-kinds=all --error-exitcode=1 $TEST_BINARY" false
    else
        echo -e "${YELLOW}‚ö†Ô∏è  No test binary found for Valgrind analysis${NC}"
    fi
else
    if ! command -v valgrind &> /dev/null; then
        echo -e "${YELLOW}üì¶ valgrind not found, skipping memory leak detection${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Tests not passed, skipping memory leak detection${NC}"
    fi
fi

# 10. Check for undefined behavior with UBSan (if supported)
echo -e "\n${BLUE}üîç Undefined behavior detection...${NC}"
if command -v clang++ &> /dev/null; then
    echo "Testing with UBSan..."
    # This is a simple check - in a real project you'd have a separate UBSan build
    echo "UBSan integration would require dedicated build configuration"
    echo "Consider adding UBSan flags: -fsanitize=undefined -fno-sanitize-recover=all"
else
    echo -e "${YELLOW}üì¶ clang++ not found, skipping UBSan checks${NC}"
fi

# Final status check
echo -e "\n${BLUE}==================================================${NC}"
echo -e "${BLUE}üèÅ Pre-push Hook Summary${NC}"
echo "=================================================="

# Check critical failures
CRITICAL_FAILURES=false

if [ "$BUILD_PASSED" != "true" ]; then
    echo -e "${RED}‚ùå Build failed${NC}"
    CRITICAL_FAILURES=true
fi

if [ "$TESTS_PASSED" != "true" ]; then
    echo -e "${RED}‚ùå Tests failed${NC}"
    CRITICAL_FAILURES=true
fi

if [ "$CRITICAL_FAILURES" = "true" ]; then
    echo -e "\n${RED}üö´ PUSH BLOCKED${NC}"
    echo -e "${RED}Critical checks failed. Please fix the issues above before pushing.${NC}"
    echo -e "\n${YELLOW}üí° Tip: Use 'git commit --no-verify' only in emergencies${NC}"
    exit 1
else
    echo -e "\n${GREEN}‚úÖ ALL CRITICAL CHECKS PASSED${NC}"
    echo -e "${GREEN}üöÄ Ready to push!${NC}"

    # Show warnings if any
    echo -e "\n${YELLOW}‚ÑπÔ∏è  Note: Some non-critical checks may have warnings.${NC}"
    echo -e "${YELLOW}    Review the output above for details.${NC}"

    # Show analysis reports location
    if [ -f "cppcheck-report.xml" ]; then
        echo -e "${BLUE}üìä cppcheck report: cppcheck-report.xml${NC}"
    fi
    if [ -f "coverage.info" ]; then
        echo -e "${BLUE}üìä Coverage report: coverage.info (use 'genhtml coverage.info --output-directory coverage_html')${NC}"
    fi

    exit 0
fi