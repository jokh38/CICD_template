#!/usr/bin/env python
"""Post-generation hook for C++ project."""

import os
import subprocess
import sys


def run_command(cmd, check=True):
    try:
        result = subprocess.run(
            cmd, shell=True, check=check, capture_output=True, text=True
        )
        return result.returncode == 0
    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")
        return False


def initialize_git():
    print("‚Ä¢ Initializing git repository...")
    run_command("git init")

    # Configure git user if not already configured
    if not run_command("git config user.name", check=False):
        run_command('git config user.name "Template User"')
    if not run_command("git config user.email", check=False):
        run_command('git config user.email "template@example.com"')

    run_command("git add .")
    run_command('git commit -m "Initial commit from template"')


def setup_build_directory():
    print("‚Ä¢ Creating build directory...")
    os.makedirs("build", exist_ok=True)


def setup_serena_configuration():
    """Create Serena-specific configuration and memory system for C++ projects."""
    print("‚Ä¢ Setting up Serena configuration...")

    use_ai = "{{ cookiecutter.use_ai_workflow }}"

    if use_ai != "yes":
        print("   ‚ö†Ô∏è  AI workflow disabled - skipping Serena configuration")
        return False

    # Create .serena directory structure
    serena_dir = ".serena"
    memories_dir = os.path.join(serena_dir, "memories")

    try:
        os.makedirs(memories_dir, exist_ok=True)

        # Create project configuration file
        project_name = "{{ cookiecutter.project_name }}"
        project_description = "{{ cookiecutter.project_description }}"
        cpp_standard = "{{ cookiecutter.cpp_standard }}"
        build_system = "{{ cookiecutter.build_system }}"

        config_content = f"""# Serena Project Configuration
# Generated by CICD Template for {project_name}

project:
  name: "{project_name}"
  description: "{project_description}"
  language: "cpp"
  standard: "C++{cpp_standard}"
  build_system: "{build_system}"

# Recommended Serena settings for this project
serena_config:
  # Enable all tools for maximum value
  enable_shell_tools: true
  enable_editing_tools: true
  enable_web_access: true

  # Recommended context for Claude Desktop users
  context: "desktop-app"

  # Recommended modes for different tasks
  modes:
    planning_tasks: ["planning", "one-shot"]
    editing_tasks: ["editing", "interactive"]
    development_sessions: ["planning", "interactive"]

  # Project-specific settings
  build_command: "cmake --build build"
  test_command: "ctest --test-dir build --output-on-failure"
  format_command: "clang-format -i src/**/*.cpp src/**/*.hpp"
  tidy_command: "clang-tidy src/**/*.cpp -- -I./include"

  # Memory system enabled
  enable_memories: true

  # Quality integration
  respect_git_hooks: true
  auto_fix_formatting: true
  run_tests_on_changes: true

# Development workflow integration
workflow:
  # Serena can use these commands for autonomous development
  configure_command: >-
    cmake -B build -G {
            "Ninja" if "{{ cookiecutter.use_ninja }}" == "yes" else "Unix Makefiles"
        }
  clean_build: "rm -rf build && cmake -B build && cmake --build build"
  run_tests: "ctest --test-dir build --verbose"
  static_analysis: "clang-tidy src/**/*.cpp -- -I./include"

  # Pre-commit integration
  pre_commit_test: "pre-commit run --all-files"

# Build variants
build_variants:
  debug: "cmake -B build -DCMAKE_BUILD_TYPE=Debug"
  release: "cmake -B build -DCMAKE_BUILD_TYPE=Release"
  rel_with_deb_info: "cmake -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo"
"""

        config_file = os.path.join(serena_dir, "config.yml")
        with open(config_file, "w", encoding="utf-8") as f:
            f.write(config_content)

        print("   ‚Ä¢ Serena configuration created")

        # Create initial memory file with project information
        memory_content = f"""# Project Memory: {project_name}
# Generated on project creation

## Project Overview
{project_description}

## Technical Stack
- **Language**: C++{cpp_standard}
- **Build System**: {build_system.upper()}
- **Testing**: {{
    'GoogleTest' if '{{ cookiecutter.testing_framework }}' == 'gtest'
    else 'Catch2/Doctest'
}}
- **Code Formatting**: clang-format
- **Static Analysis**: clang-tidy
- **Compilation Cache**: {{
    'sccache enabled' if '{{ cookiecutter.enable_cache }}' == 'yes'
    else 'sccache disabled'
}}
- **Build Generator**: {{
    'Ninja' if '{{ cookiecutter.use_ninja }}' == 'yes'
    else 'Unix Makefiles'
}}
- **Git Hooks**: Pre-commit hooks installed and configured

## Project Structure
```
src/           - Main source code directory
include/       - Header files
tests/         - Test files using {{ cookiecutter.testing_framework }}
build/         - Build output directory
docs/          - Project documentation
git-hooks/     - Local CI/CD hooks
configs/       - Tool configuration files
.serena/       - Serena AI configuration and memories
```

## Development Workflow
1. **Configure Build**: `cmake -B build -G {{
    "Ninja" if "{{ cookiecutter.use_ninja }}" == "yes"
    else "Unix Makefiles"
}}`
2. **Build Project**: `cmake --build build`
3. **Run Tests**: `ctest --test-dir build --output-on-failure`
4. **Format Code**: `clang-format -i src/**/*.cpp include/**/*.hpp`
5. **Static Analysis**: `clang-tidy src/**/*.cpp -- -I./include`
6. **Git Hooks**: Automatic on commit (formatting, build, testing)

## Quality Standards
- All code must pass clang-format formatting
- All code must pass clang-tidy static analysis
- All tests must pass before commits
- Build must succeed before commits
- Pre-commit hooks enforce quality standards
- Use `git commit --no-verify` only in emergencies

## AI Assistant Integration
This project is configured for Serena MCP integration with:
- Shell execution tools enabled for autonomous development
- File editing tools for automatic bug fixes and refactoring
- Web access for dependency research and C++ best practices
- Memory system for project-specific knowledge
- Integration with existing git hooks and testing frameworks

## Common Commands
- Configure build: `cmake -B build`
- Build project: `cmake --build build`
- Run tests: `ctest --test-dir build --output-on-failure`
- Format code: `clang-format -i src/**/*.cpp include/**/*.hpp`
- Static analysis: `clang-tidy src/**/*.cpp -- -I./include`
- Clean build: `rm -rf build && cmake -B build && cmake --build build`
- Pre-commit check: `pre-commit run --all-files`

## Build Types
- Debug: `cmake -B build -DCMAKE_BUILD_TYPE=Debug`
- Release: `cmake -B build -DCMAKE_BUILD_TYPE=Release`
- RelWithDebInfo: `cmake -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo`
"""

        memory_file = os.path.join(memories_dir, "project_overview.md")
        with open(memory_file, "w", encoding="utf-8") as f:
            f.write(memory_content)

        print("   ‚Ä¢ Initial memory created")

        # Create Serena usage guide
        usage_guide = f"""# Serena Usage Guide for {project_name}

## Quick Start
1. Ensure Serena MCP is installed and enabled in Claude Code
2. Enable all tools (shell execution, editing, web access) for maximum value
3. Start with onboarding mode to let Serena analyze the C++ codebase
4. Use appropriate modes for different tasks

## Recommended Modes
- **Planning tasks**: `--mode planning --mode one-shot`
- **Code editing**: `--mode editing --mode interactive`
- **Development sessions**: `--mode planning --mode interactive`

## Capabilities
- **Build Management**: Serena can run CMake configuration and build commands
- **Test Execution**: Run ctest and fix test failures automatically
- **Code Quality**: Auto-fix clang-format and clang-tidy issues
- **C++ Refactoring**: Modern C++ refactoring and best practices application
- **Documentation**: Generate and update C++ documentation
- **Error Correction**: Self-correct based on compilation and test results

## Integration Notes
- Git hooks will validate Serena's changes (build, format, test)
- All changes are tracked through git for easy review
- Serena respects existing CMake and tool configuration files
- Memory system maintains C++ project context across sessions
- Works seamlessly with sccache for faster compilation

## C++ Specific Features
- **CMake Integration**: Serena can modify CMakeLists.txt files
- **Header Management**: Automatic include guard and pragma once handling
- **Modern C++**: Apply C++{cpp_standard} best practices
- **Template Handling**: Assist with template code generation and debugging
- **Build Optimization**: Suggest and implement build improvements

## Best Practices
- Start with clean git state when using Serena
- Review Serena's changes with `git diff` before committing
- Allow Serena to complete onboarding on first use
- Use read-only mode for code analysis only
- Keep backups of important header files
- Test builds after significant changes
"""

        guide_file = os.path.join(serena_dir, "USAGE_GUIDE.md")
        with open(guide_file, "w", encoding="utf-8") as f:
            f.write(usage_guide)

        print("   ‚Ä¢ Usage guide created")

        return True

    except Exception as e:
        print(f"   ‚ùå Error setting up Serena configuration: {e}")
        return False


def install_serena_mcp():
    """Install Serena MCP server for Claude Code with enhanced configuration."""
    print("‚Ä¢ Setting up Serena MCP integration...")

    use_ai = "{{ cookiecutter.use_ai_workflow }}"

    if use_ai != "yes":
        print("   ‚ö†Ô∏è  AI workflow disabled - skipping Serena MCP setup")
        return False

    # Setup Serena configuration first
    setup_serena_configuration()

    # Check if Claude Code CLI is available
    if not run_command("which claude", check=False):
        print("   ‚ö†Ô∏è  Claude Code CLI not found - skipping Serena MCP setup")
        return False

    # Check if Serena MCP is already installed
    if run_command("claude mcp list | grep serena", check=False):
        print("   ‚Ä¢ Serena MCP already installed")
        return True

    # Install Serena MCP
    print("   ‚Ä¢ Installing Serena MCP server...")
    install_cmd = 'claude mcp add-json "serena" \'{"command":"uvx","args":["--from","git+https://github.com/oraios/serena","serena-mcp-server"]}\''

    if run_command(install_cmd, check=False):
        print("   ‚Ä¢ Serena MCP installed successfully")
        return True
    else:
        print("   ‚ö†Ô∏è  Failed to install Serena MCP")
        return False


def install_pre_commit():
    """Install pre-commit hooks for C++ projects."""
    print("‚Ä¢ Installing pre-commit hooks...")

    use_git_hooks = "{{ cookiecutter.use_git_hooks }}"

    if use_git_hooks == "no":
        print("   ‚ö†Ô∏è  Git hooks disabled by configuration")
        return False

    # Check if pre-commit is available in the system
    if not run_command("which pre-commit", check=False):
        print("   ‚Ä¢ Installing pre-commit...")
        run_command("pip install pre-commit", check=False)

    # Install pre-commit hooks
    return run_command("pre-commit install", check=False)


def install_pre_push_hook():
    """Install custom pre-push hook for testing and dynamic analysis."""
    print("‚Ä¢ Installing pre-push hook...")

    use_git_hooks = "{{ cookiecutter.use_git_hooks }}"

    if use_git_hooks == "no":
        print("   ‚ö†Ô∏è  Git hooks disabled by configuration")
        return False

    # Copy the pre-push hook template to .git/hooks/
    hooks_dir = ".git/hooks"
    pre_push_source = "hooks/pre-push"
    pre_push_target = os.path.join(hooks_dir, "pre-push")

    if os.path.exists(pre_push_source):
        try:
            import shutil

            shutil.copy2(pre_push_source, pre_push_target)
            os.chmod(pre_push_target, 0o755)  # Make executable
            return True
        except Exception:
            return False
    return False


def print_next_steps():
    project_name = "{{ cookiecutter.project_name }}"
    project_slug = "{{ cookiecutter.project_slug }}"
    build_system = "{{ cookiecutter.build_system }}"
    use_git_hooks = "{{ cookiecutter.use_git_hooks }}"
    use_ai = "{{ cookiecutter.use_ai_workflow }}"

    print("\n" + "=" * 60)
    print("‚úÖ Project created!")
    print("=" * 60)
    print(f"\n‚Ä¢ Project: {project_name}")
    print(f"‚Ä¢ Build: {build_system}")
    print(f"‚Ä¢ Git Hooks: {use_git_hooks}")
    print(f"‚Ä¢ AI Workflow: {use_ai}")

    if use_git_hooks == "yes":
        print("\n‚Ä¢ Pre-commit hooks are installed and will run automatically")
        print("‚Ä¢ Pre-push hooks are installed and will run tests/dynamic analysis")
        print("‚Ä¢ Run 'pre-commit run --all-files' to check all files manually")
        print("‚Ä¢ üî¥ IMPORTANT: Never use 'git commit --no-verify' - bypasses checks!")
        print("‚Ä¢ üî¥ IMPORTANT: Never use 'git push --no-verify' - bypasses testing!")
    else:
        print("\n‚Ä¢ Git hooks are disabled - manual quality checks required")

    if use_ai == "yes":
        print("‚Ä¢ Serena MCP integration is configured for enhanced AI capabilities")

    print("\n‚Ä¢ Create GitHub repository and push:")
    print("  1. Create a new repository on GitHub")
    print("  2. git remote add origin <your-github-repo-url>")
    print("  3. git push -u origin main")


def setup_claude_context():
    """Copy entire .github/claude/ directory and customize CLAUDE.md
    for new projects."""
    print("‚Ä¢ Setting up Claude AI context...")

    use_ai = "{{ cookiecutter.use_ai_workflow }}"

    if use_ai != "yes":
        print("   ‚ö†Ô∏è  AI workflow disabled - skipping Claude context setup")
        return False

    # Ensure .github/claude directory exists
    claude_dir = ".github/claude"
    os.makedirs(claude_dir, exist_ok=True)

    # Define source directory paths - try multiple approaches
    script_dir = os.path.dirname(
        os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
    )
    possible_source_dirs = [
        # Try from current working directory (most reliable after cookiecutter)
        os.path.join(os.getcwd(), "..", "..", ".github", "claude"),
        # Try from script directory
        os.path.join(script_dir, ".github", "claude"),
        # Try absolute path fallback
        "/home/jokh38/apps/CICD_template/.github/claude",
    ]

    source_claude_dir = None
    for path in possible_source_dirs:
        if os.path.exists(path):
            source_claude_dir = path
            break

    if not source_claude_dir:
        print("   ‚ö†Ô∏è  Source .github/claude/ directory not found")
        return False

    # Copy entire .github/claude/ directory structure
    import shutil

    copied_files = []

    try:
        # Walk through source directory and copy all files
        for root, _dirs, files in os.walk(source_claude_dir):
            # Calculate relative path from source_claude_dir
            rel_path = os.path.relpath(root, source_claude_dir)
            if rel_path != ".":
                target_dir = os.path.join(claude_dir, rel_path)
            else:
                target_dir = claude_dir

            # Create target directory if it doesn't exist
            os.makedirs(target_dir, exist_ok=True)

            for file in files:
                source_file = os.path.join(root, file)
                target_file = os.path.join(target_dir, file)

                # Copy file
                shutil.copy2(source_file, target_file)
                copied_files.append(os.path.relpath(target_file))

                # Customize CLAUDE.md if this is the file
                if file == "CLAUDE.md":
                    customize_claude_md(target_file)

        print(f"   ‚Ä¢ Copied {len(copied_files)} AI workflow files to .github/claude/")
        return True

    except Exception as e:
        print(f"   ‚ùå Error copying .github/claude/ directory: {e}")
        return False


def customize_claude_md(claude_md_path):
    """Customize CLAUDE.md file with project-specific values."""
    try:
        # Read the file
        with open(claude_md_path, encoding="utf-8") as f:
            content = f.read()

        # Get actual cookiecutter values
        project_name = "{{ cookiecutter.project_name }}"
        project_description = "{{ cookiecutter.project_description }}"
        cpp_standard = "{{ cookiecutter.cpp_standard }}"

        # Replace cookiecutter variables with actual project values
        replacements = {
            "{{cookiecutter.project_name}}": project_name,
            "{{cookiecutter.project_description}}": project_description,
            "{{cookiecutter.cpp_standard}}": cpp_standard,
        }

        for template_var, actual_value in replacements.items():
            content = content.replace(template_var, actual_value)

        # Handle Jinja2 conditionals for C++ projects
        conditional_str = (
            "{% if cookiecutter.python_version is defined %}Python "
            "{{cookiecutter.python_version}}{% else %}C++ "
            "{{cookiecutter.cpp_standard}}{% endif %}"
        )
        content = content.replace(conditional_str, f"C++ {cpp_standard}")

        # Write the customized file
        with open(claude_md_path, "w", encoding="utf-8") as f:
            f.write(content)

        return True

    except Exception as e:
        print(f"   ‚ö†Ô∏è  Error customizing CLAUDE.md: {e}")
        return False


def copy_claude_md():
    """Copy HIVE_CLAUDE.md from docs/ directory as CLAUDE.md to project root."""
    import shutil

    print("‚Ä¢ Setting up CLAUDE.md documentation...")

    # Define possible source paths for HIVE_CLAUDE.md
    script_dir = os.path.dirname(
        os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
    )
    possible_source_paths = [
        # Try from current working directory (most reliable after cookiecutter)
        os.path.join(os.getcwd(), "..", "..", "docs", "HIVE_CLAUDE.md"),
        # Try from script directory
        os.path.join(script_dir, "docs", "HIVE_CLAUDE.md"),
        # Try absolute path fallback
        "/home/jokh38/apps/CICD_template/docs/HIVE_CLAUDE.md",
    ]

    source_hive_claude = None
    for path in possible_source_paths:
        if os.path.exists(path):
            source_hive_claude = path
            break

    if not source_hive_claude:
        print("   ‚ö†Ô∏è  Source HIVE_CLAUDE.md not found in docs/")
        return False

    try:
        # Copy HIVE_CLAUDE.md as CLAUDE.md to project root
        shutil.copy2(source_hive_claude, "CLAUDE.md")
        print("   ‚Ä¢ CLAUDE.md copied to project root")
        return True
    except Exception as e:
        print(f"   ‚ùå Error copying HIVE_CLAUDE.md: {e}")
        return False


def main():
    try:
        # Setup Claude AI context if enabled
        setup_claude_context()
        copy_claude_md()

        initialize_git()
        setup_build_directory()
        install_pre_commit()
        install_pre_push_hook()
        install_serena_mcp()
        print_next_steps()
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
